* P5js
** P5js vs. Processing
   - Use createCanvas() instead of size() to make a sketch.
   - Use frameRate() with no arguments to get frame rate, instead of variable frameRate.
   - Loading methods (file loading, url loading) take a callback.
   - New preload() method that is called before setup().
   - Use mouseIsPressed() to get a resulting bool, instead of mousePressed()
   - p5.Vector.random2D() might not be working.
   - p5 global variables are not available outside of p5 contexts, like setup() and draw().
   - pop() and push() combines push/popMatrix and push/popStyle.
   - Touch events are available, lookup touchX, touchStarted, touches[] array.
   - Use createVector() instead of new PVector().
** Object oriented things
   - p5.Vector.get() returns a copy of the instanced Vector.
     - Useful when passing a Vector as a function argument to help avoid mutating a Vector that is shared by other functions.
     - Static methods, like p5.Vector.add(), can be another strategy to solve this problem.
* Vectors
  - In graphics, we refer to the Euclidean vector, an entiry with magnitude and direction.
  - A vector might describe a displacement from two positions.
** What is location?
   - We can consider an object's location to be it's displacement from the world's origin.
     - For example, if my co-ordinates are (4, 5), that's how far I'm displaced from (0, 0).
** What is motion?
   - Motion is expressed by the algorithm location = location + velocity.
   - Velocity is just a translation vector. It becomes "velocity" when we think of it in reference to an amount of time passing.
** Vector magnitude
   - The length of a vector, calculated using Pythagorean theorem.
** Normalizing vectors
   - Normalizing is taking a vector of any length, keeping it pointed in the same direction, and changing its length/magnitude to 1.
   - This is done by first calculating the vector magnitude, then dividing each component (e.g. x, y, z) by the magnitude.
   - Normalized vectors are usually used to express direction.
   - Each component will be 1 or less. If a normalized component is 1, all the others will be zero as it means the vector is perfectly aligned with an axis.
** Random Vectors
   - p5.Vector.random2D() will produce a normalized vector (components less than 1).
   - The implementation is p5js might be incomplete.
** Static functions
   - Static functions are attached to the class and can be called without instantiating an object.
   - E.g. calling the static p5.Vector.add(v1, v2) will return a new vector, where the non-static v1.add(v2) will mutate v1.
   - Processing's Vector classes have a slew of static functions to check out.
** Acceleration
   - Acceleration is the rate of change of velocity over time, also expressed as a vector.
   - The rest of NOC will be controlling all moving objects with just acceleration, which seems pretty standard among graphics programming.
   - All things in nature must move with acceleration.
   - Acceleration values are small, like (-0.001, 0.01), because they accumulate per frame and quickly add up.
     - Note that the negative x value above does not mean "slow down". Like any other vector, these values refer to direction and magnitude. Negative values simply mean a negative direction along the axis.
     - Proper "slowing down" would be accelerating in the reverse direction.
   - It's important to remember that acceleration doesn't just refer to speeding up or slowing down, but any change in velocity/direction at all.
** Accelerating towards something
   - To accerlerate towards something, you add velocity in that direction.
   - Find the direction to go with by getting a vector from current position to target (target - currrentPosition), then normalizing the resulting vector.
   - The normalized direction vector now needs a magnitude, which is the speed at which we will accelerate towards the target. Multiply the vector by the desired factor.
   - The resulting vector is the new acceleration.
* Forces
  A vector that causes an object with mass to accelerate. Location is adjusted by velocity, and velocity by acceleration. Acceleration, before this chapter, was where it all began. Acceleration is adjusted by force. Now, force is where it all begins.
** Newton's First Law
   - An object at rest stays at rest, an object in motion stays in motion (absent of any forces at all).
   - Re-stated as:
     - An object at rest stays at rest and an object in motion stays in motion at a constant speed and direction unless acted upon by an imbalanced force.
   - E.g. an object that is moving in a space with no forces at work will never stop moving.
** Newton's Second Law
   - Net force equals mass times acceleration.
   - Net force is the sum of all forces (e.g. wind, gravity, friction).
   - Re-stated as:
     - Acceleration is directly proportional to force, and inversely proportional to mass.
     - The harder you are pushed, the faster you'll move (accelerate). The bigger you are, the slower you'll move.
** Newton's Third Law
   - For every action there is an equal and opposite reaction.
   - Re-stated as:
   - Forces always occur in pairs. The two forces are of equal strength but in opposite directions.
   - Think of pushing on a large truck. You can't move it. The force exerted on your hand is equal to the force that your hand is applying to the truck. Other factors influence this, like whether you're wearing roller skates.
** Mass
   - A measure of the amount of matter in the object, measured in kilograms.
   - Weight is often mistaken for mass. Weight, measured in newtons, is the force of gravity on an object.
   - On the moon, our mass is the same but our weight is different.
   - Density is the unit of mass per volume. E.g. grams per cubic meter.
** Force accumulation
   - Newton's Second Law is that net force equals mass times acceleration.
   - To calculate net force, we accumulate all the forces acting upon an object.
   - In Processing, applyForce() just per force per moment of time.
     - This also means clearing acceleration (setting it to zero) before each update() is called.
** Acceleration has no memory
   - Acceleration is calculated at each moment in time based on the forces present.
   - This is different from location, where we take into account the previous frames location to determine the current location. With acceleration, we disregard the previous frame's acceleration.
** Creating forces
   - Making imaginary forces or modelling real ones can be as simple as making a Vector. e.g wind = createVector(0.01, 0);
** Gravity scaled by mass
   - Acceleration = force/mass only gets us so far.
   - Some forces are relative to the object's mass, like gravity.
   - Accurate gravity should have its Y component scaled by the mass of the object it is affecting.
** Dissipative force
   - A force in which the total energy of the system decreases while the object is in motion.
   - E.g. friction
** Friction
   - Friction = -1 * coefficient * normal force * velocity unit vector.
   - There is static friction and kinetic friction, we're only going to focus on static.
   - Friction points the opposite direction as velocity. Hence, the unit vector (direction) of velocity is multiplied by -1 in the friction formula. Therefore, take the velocity vector, normalize it, and multiply by -1.
   - The coefficient of friction is the strength of friction on a particular surface.
   - Normal force is the perpendicular to motion along a surface. E.g. gravity pulls down a moving car, according to the Third Law the road pushes back on the car with an equal amount of force. The road is the normal force.
** Air and Fluid Resistance
   - Friction also occurs when an object passes through liquid or gas (e.g. drag or viscous force).
   - Drag force = 0.5 * liquid density * sq(velocity) * frontal area * coefficient * velocity unit vector.
   - Coefficient is the strength of the force
   - Frontal area is the size of the object face pushing through the liquid/gas. Think aerodynamics.
** Gravitational Attraction
   - The way two objects attract each other (often, for us, one of those objects is Earth).
   - Gravitational constant is 6.67428 x 10^-11. In processing, make it whatever looks good.
   - GravForce = ((GravConstant * mass(obj1) * mass(obj2)) / dist(obj1, obj2)^2) * unit vector(dist(obj1, obj2))
     - multiply GravConstant and object masses, divide by distance between objects squared, multipy by direction of distance.
** Making objects talk to each other
   - In the code examples, we made a Mover object that starts out static, but we can applyForce() to. We also made an Attractor object that knows the formula for gravitational attraction.
   - We could attract(Mover, Attractor), or we could Mover.attractTo(Attractor), or we could Attractor.attract(Mover). But all these are tightly coupled solutions.
   - To decouple the relationship, have the Attractor.attract() return a force vector, which is a far more general type, and applyForce(force vector).
   - E.g. Vector f = Attractor.attract(Mover); Mover.applyForce(f).
* Oscillation
